### Введение. 

**Блокчейн** _(англ. Blockchain — цепочка из блоков)_ — распределенное хранилище данных, основанное на цепочке соединенных между собой по определенным правилам блоков. Данная технология может быть использована как публичное хранилище любых данных, целостность которых подтверждается криптографическими алгоритмами.

Первое и наиболее популярное на данный момент применение технологии блокчейн — криптовалютные системы, и, в частности, криптовалюта Биткоин.

В данной лабораторной работе мы построим блокчейн по упрощенной модели на основе алгоритма POW (proof of work) с неизменной сложностью, чтобы познакомиться с данной технологией.

В качестве языка программирования мы будем использовать Python и в качестве сетевого фреймворка Flask.

**Python** — высокоуровневый язык программирования, отличающийся минималистичным синтаксисом. Язык напоминает англоязычный псевдокод, при высокой выразительности и развитой экосистеме и поэтому пользуется популярностью в области образования и научных исследований. 

**Flask**— легковесный веб-фреймворк, позволяющий за минимальное количество строк кода развернуть REST API для управления узлом, поэтому мы сможем сконцентрироваться на создании блокчейна.

### Подготовка.

Установите Python версии 3.6 и выше, воспользовавшись инструкциями по установке по адресу [https://www.python.org/](https://www.python.org/). Не забудьте установить менеджер пакетов pip. После успешной установки выполните следующую команду.

```
pip install pipenv
```


Откройте проект и установите необходимые зависимости, воспользовавшись менеджером установленным ранее менеджером виртуальных окружений pipenv.

```
pipenv --python=python3.6
pipenv install
```


В дальнейшем, для запуска узлов для демонстрации или отладки, можно пользоваться командой, заменив ПОРТ на номер желаемого сетевого порта.

```
pipenv run python blockchain.py --port ПОРТ
```


Проверив, что после запуска сервера GET запрос на _localhost:ПОРТ/ping_ возвращает код _200 OK_, можно приступать к следующим шагам.

### Представление блокчейна

Класс Blockchain, представляет наш блокчейн и имеет следующие функции.

* функция `get_latest_block` отвечают за добавление и получение информации о блоках, находящихся в нашем блокчейне;

* функция `new_transaction` добавляет новую транзакцию в список транзакций, ожидающих подтверждения;

* функция `new_block` создает новый блок на основе последнего известного блока, списка транзакций и доказательства работы; 

* функция `hash` считает хеш переданного ей блока алгоритмом _sha256_;

* функции `proof_of_work`, `valid_proof`, `valid_chain` и `resolve_conflicts` нужны для достижения консенсуса — об этом будет рассказано далее.

### Блоки

Блок — запись, содержащая в себе следующие поля:

* `index` — порядковый номер блока. Первый блок в блокчейне называется генезисом и имеет порядковый номер 1;

* `timestamp` — дата и время "рождения" блока;

* `previous_hash` — хеш предыдущего блока — основа связности блокчейна;

* `transactions` — данные о транзакциях, хранящихся в блоке;

* `proof` — доказательство работы (proof of work), об этом будет рассказано далее;

### Доказательство работы и консенсус

Как уже было сказано, блокчейн — хранилище данных, представленное как цепочка из блоков. Для того, чтобы хранить данные распределенно, необходимо разработать **алгоритм консенсуса**, который бы мог выявлять, какая из двух различных цепочек является актуальной на данный момент. Так как удалять информацию из цепочки нельзя, простейшей имплементацией алгоритма консенсуса было бы *считать актуальной наиболее длинную цепочку блоков*. Однако, данный алгоритм может быть атакован мошенниками, используя две ветви транзакций, в нужный момент сделав публичной ветвь, держащуюся в тени и имеющую большее количество транзакций, таким образом, затерев публичную до этого ветку. 

Для предотвращения подобных атак был придуман алгоритм **proof of work**. Данный алгоритм представляет собой задачу, которую сложно решить, но легко проверить ее решение. В качестве такой задачи может быть использована следующая: *"Найти число (proof) при подстановке которого в блок его хеш по алгоритму sha256 имеет на конце N нолей"*. Варьируя значение *N*, мы можем управлять сложностью алгоритма с изменением количества мощностей, участвующих в блокчейне.

В нашей демонстрации блокчейна уже есть необходимые для работы функции.

* функция `generate_proof` находит требуемое доказательство перебором, начиная от 0;

* функция `validate_proof` проверяет правильность полученного доказательства;

* функция `synchronize_blockchain` принимает две цепочки и сохраняет как актуальную наибольшую валидную цепочку из двух.

### Демонстрация

Проект включает в себя REST API, которое обращается к определенным выше функциям и позволяет управлять узлом блокчейна.

* `GET /mine`

  запуск добычи нового блока;

* `GET /nodes/resolve`

  запуск алгоритма консенсуса;

* `POST /transactions/new` 

  создание новой транзакции, тело запроса:

```
{
	"recipient":"lol",
	"sender":"lul",
	"amount":"2"
}
```


* `GET /blocks`

	Получение списка всех блоков;

* `POST /nodes/register`

  регистрация нового узла-соседа, тело запроса:

```
{
  "nodes": [
    “localhost:5001”,
    ...
  ]
}
```


### Дальнейшее развитие

Данная лабораторная работа показала базовые принципы построения блокчейна как надежной публичной распределенной базы данных. Для того чтобы углубиться в технологию, можно сделать одно из следующих улучшений:

* добавить управление сложностью при наращивании суммарной вычислительной мощности сети, чтобы средняя скорость добычи новых блоков оставалась постоянной;

* добавить авторизацию и подтверждение правильности транзакций, построив криптовалюту на базе нашего блокчейна;

* попытаться внедрить иной алгоритм доказательства, такой как proof of stake или proof of authority

